use crate::Playable;
use rand;
use std::time::{Duration, Instant};

// Home made Monte Carlo player. At first simple.

/// Node =  en "gamestate" i et tre, Paramtere: Moves, no_visited,total_result
/// Move = et bestemt trekk, inneholder link til child node, no_visited,totalt_result
/// TreeWalk = Vec med moves og Nodes som skal back propageres.
pub mod monto_carlo {

    use log::debug;
    use rand::Rng;
    use time::ext::InstantExt;
    use std::collections::HashMap;
    use std::time::Instant;
    use std::time::Duration;
    use boardgame_game::game::game::*;


    /*struct Move {
        name: String,
        next_state: Vec<usize>,

    }*/
    #[derive(Clone)]
    struct Node {
        moves: HashMap<&'static str, Option<usize>>,
        no_visited: usize,
        total_score: usize,
        is_fully_expnded: bool,
    }

    impl Default for Node {
        fn default()-> Self {
        Node {
            moves: HashMap::new(),
            no_visited: 0,
            total_score: 0,
            is_fully_expnded: false,
        }

    }
    }

        #[derive(Clone, Default)]
    pub struct PlayerMC {
        pub name: String,
        pub sec_to_move: u16,
        nodes: Vec<Node>,
        total_rollouts: usize,
    }

    impl crate::player::Agentish for PlayerMC {
        fn get_name(&self) -> String {
            self.name.to_string()
        }

        fn get_move<T: crate::Playable>(
            &self,
            moves: &Vec<String>,
            active_player: &str,
            game: &T,
        ) -> Option<String> {
            // let mut rng = rand::thread_rng();
            let cmove = self.monte_carlo_tree_search(active_player, game); //&moves[rng.gen_range(0..moves.len())];
            debug!("I({}) move {}", self.name, cmove.unwrap());
            return cmove;
        }
    }

    impl PlayerMC {
        pub fn new(game_static: &crate::GameStatic) -> Self {
            //let mut brain = BrainDiamond::default();
            //brain.game_name = game_static.name.clone();
            let mut myself = Self {
                name: "Logic gates".to_string(),
                sec_to_move: 5,
                nodes: vec![Node::default()],
                total_rollouts: 0,
                //  is_loaded: false,
                //  brain: brain,
            };

            //let _ = myself.get_ready(game_static);
            myself
        }

        /// main function for the Monte Carlo Tree Search. Return best move
        fn monte_carlo_tree_search<T: crate::Playable>(&self, active_player: &str, &game: &T)->Option<String> {
            let move_start_time = Instant::now();

            while self.has_time_left(&move_start_time) {
                let path_to_leaf = self.traverse(0) ; // 0 == root
                let simulation_result = self.rollout(game.clone(), path_to_leaf.last().copied());
                self.backpropagate(leaf, simulation_result);
            }
	        return self.best_child(0);
        }

        /// function for node traversal
        /// traverse == walk in tree to node is a leaf
        fn traverse(&self, node: TSNode)->Result<TSNode> {
            while fully_expanded(node){
                node = best_uct(node);
            }
            // in case no children are present / node is terminal
            return pick_unvisited(node.children) || node;
        }

        /// function for the result of the simulation
        fn rollout<T: crate::Playable>(&self, &game: T, node: &usize)->usize{
            while ! game.is_terminal(){
                todo!("Rollout start med å lage en tilfeldig move slik som random. Etter på skriv om til funksjon slik at lettere å bytte ut.");
                //game.play
            }
            return game.goal(node)
        }

        /// function for randomly selecting a child node
        fn rollout_policy(node: TSNode)->Result<TSNode> {
            return pick_random(node.children)
        }

        /// function for backpropagation
        fn backpropagate(node: TSNode)->Result<TSNode> {
            if is_root(node) {return None;}
            node.stats = update_stats(node, result);
            backpropagate(node.parent)
        }

        /// function for selecting the best child
        /// node with highest number of visits
        fn best_child(node: TS)->Result<TSNode>  {
            todo!("pick child with highest number of visits");
        }

        /// True if yes
        /// False if no
        fn has_time_left(&self,move_start: &Instant) -> bool {
            return Duration::from_secs(self.sec_to_move) >= move_start.elapsed();
        }

    }
}
